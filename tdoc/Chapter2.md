## Chapter 2 The structure of the Java Virtual Machine 

该文档描述了一个抽象的机器规范，但并不指定任何一种 JVM 实现的具体行为。

为了正确地实现 JVM, 你必须能够分析 `class` 的文件格式并且执行在其中定义的行为。
实现细节不是 JVM 规范的一部分——规范不会约束实现者的创造力。
例如，运行时数据区域的内存布局，垃圾收集算法 (GC *garbage-colleciton*) 的选择，以及设计在指令集内部的优化，比方说，将其再次翻译为机器码。这些设计的使用都是实现者的自由。

参考 *The Unicode Standard, Version 13.0*, 本规范中，所有关于 Unicode 的描述都能在 https://www.unicode.org/ 中找到。

### Chapter 2.1 `class` 文件格式

JVM 能执行的字节码表示为一种平台无关的二进制格式，往往会存储在文件中，称为 `class` 文件格式。
该文件格式精确地定义了类和接口的表式形式，包括诸如字节序这样在某一平台会被视为理所当然的细节。

Chapter 4 包括了 `class` 格式的细节。

### Chapter 2.2 数据类型

像 Java 语言一样，Java Virtual Machine 把数据为了两种类型：基本类型和引用类型。
相应地，两种类型的数据都可以被存储至变量中，进行参数传递，通过方法（ *method* 也可以理解成「函数 ) 进行返回，或被操作。

JVM 希望几乎所有类型检查都能借助编译器在开始运行前完成，而不必再让 JVM 自己来检查。

基础类型的值不需要在运行时被标记上类型，也不需要与引用类型区分开。
取而代之的，是 JVM 的指令集本身在定义之时，便隐式地描述了操作数的类型。
举个例子，指令 `iadd`, `ladd`, `fadd`, `dadd` 是 JVM 中用于进行两个数值类型的加法运算的指令，其会得到一个同样是数值类型的结果。而不同的指令针对性地描述了不同的操作数类型：`int`, `long`, `float`, `double`. 
在第 11 小节中，我们会有更详细的指令对数据类型的支持描述汇总。

### Chapter 2.3 基本类型、值

基本类型包括：数值类型 ( `byte` , `short` , `int` , `long` , `char` , `float` , `double` ), `boolean` 类型，`returnAddress` 类型。

整型数值类型使用补码的方式进行编码（除 `char` 类型是 16-bit unsigned 编码模式）

其中，各类型的编码长度如下：

|type|bit width|
|--|--|
|`byte`|8-bit|
|`short`|16-bit|
|`int`|32-bit|
|`long`|64-bit|

所有整型数值类型的默认值都是零。

`float` 类型遵循 `32-bit IEEE 754 binary32` 的值表示规范，`double` 为 `64-bit IEEE 754 binary64`. 
而它们的默认值为正零。(positive zero) 

`boolean` 类型（常称 *布尔类型* ） 只有两个值：`true` 和 `false`. 
默认值是 `false`. 

> 在第一版的 *Java® Virtual Machine Specification* 中没有考虑过 `boolean` 会是 JVM 中的一个类型。然而，当时 `boolean` 在 JVM 中依旧有一定的支持。
> 在第二版中，规范澄清了这个问题——将 `boolean` 明确定义为一种类型。

最后，`returnAddress` 类型是对 JVM 指令位置的描述（类比 C 的函数指针，或汇编的 .text 符号）。
所有类型中，只有 `returnAddress` 类型不是直接在 Java 语言里出现的类型。

#### Chapter 2.3.1 整型类型表示范围

`byte` : -128 ~ 127 
`short` : -32768 ~ 32767 
`int` : -2147483648 ~ 2147483647
`long` : -9223372036854775808 ~ 9223372036854775807 
`char` : 0 ~ 65535 

### Chapter 2.3.2 浮点数类型表示范围

[[TODO: 不想翻译了，又不用自己写浮点数运算的硬件。]]

### Chapter 2.3.3  `returnAddress` 类型

在 JVM 中，三条指令 `jsr`, `ret`, `jsr_w` 都需要使用到 `returnAddress` 类型。
该类型的值是指向 Java 指令的指针（，如果用 C 的方言来说的话）。
和平凡的数值类型不同，该类型既不与 Java 编程语言的任何一种类型相关，也不能在程序运行的过程中修改。（笔者注：这里的「修改」应该是指不允许进行指针算术。）

### Chapter 2.3.4 `boolean` 类型

虽然说，JVM 规定 `boolean` 是一种类型，但 Java Virtual Machine 其实只提供了非常受限的支持。
没有任何一条 JVM 指令单独地专门用于进行 `boolean` 类型相关的运算，而在实际的 JVM 运行中，布尔表达式的运算则被编译成 JVM `int` 类型间的运算。

不过呢，JVM 的确真的支持 `boolean` 类型，比如说 `boolean` 数组。
数组创建指令 `newarray` 可以创建一个 `boolean` 数组。
而数组中 `boolean` 值的访问和修改可以通过 `byte` 数组的操作指令 `baload` 和 `bastore`. 

> 在 Oracle 的 JVM 实现中，Java 语言定义的 `boolean` 数组在 JVM 中被编码为 `byte` 数组，即每个 `boolean` 类型都占 8 bit. 

### Chapter 2.4 引用类型

引用类型可以被划分为三大类：`class` 类型（类），`array` 类型（数组），`interface` 类型（接口）。
而它们的值，则是动态创建的对象、数组，或者是实现了某个接口的对象（或数组）。

数组类型描述里不包含该数组的长度，但会包含其中的成员类型。
我们还会强调数组的「元素类型」，它被递归的定义为数组的成员类型的元素类型，除非该数组的成员不再是数组。

所以，数组的元素类型，要么是基本类型，要么是 `class` 类型，要么是 `interface` 类型。

而一个引用类型的值，可以是 `null` (空值，在编程术语中常表达为不存在意。)。
*值得注意的是，`null` 引用没有一个运行时维护的类型，但它可以强制转化为任一类型。*
引用类型的默认值是 `null`. 

本规范并不规定 `null` 的编码方式。

### Chapter 2.5 运行时数据区

Java Virtual Machine 定义了不同的运行时数据区，以便在程序执行的过程中使用。
其中，有些数据区会在 JVM 初始化时创建，而在 JVM 退出时销毁。（值得注意的是，JVM 会在退出时主动回收，这是因为除了 JVM 单独运行在一个进程的情形，还有一些情形是 JVM 被外挂在某个进程内部，如果 JVM 不回收该内存，将会导致其销毁后原进程内存泄漏。） 
另一些数据区则是被各线程自身持有。这些数据区将会在该线程创建时同时创建，而在该线程退出时一同销毁。

#### Chpater 2.5.1 pc 寄存器

*pc 寄存器: 全名 program counter register, 用于描述当前 CPU 应当执行的指令位置。*

JVM 支持同时运行多个线程，因此各 JVM 线程都有它自己的 pc 寄存器。
在任意时刻，每个 JVM 线程都在执行某个方法里面的代码，而这个方法，称之为该线程的 *current method*. 
如果该方法不是 **native**, 则 pc 寄存器将会包含当前 JVM 接下来要执行的指令位置。
如果是，则 pc 的值是未定义的。(即，规范不要求该值一定是某个值，也不要求该值必须在不同的执行时间相同，不要求该值满足某种序列或规律。) 
pc 寄存器的位宽足以保存一个 `returnAddress` 类型的值或者一个该平台的本地指针。

*译者注：真的有必要吗？最后这一句话可能是不正确的。* 

#### Chapter 2.5.2 JVM 栈 (stack)

每个 JVM 线程都有一个私有的 JVM 栈，在该线程创建的同时被创建。
栈上存储的是栈帧 (frame) 。
这里所说的栈，和传统的编程语言（比如 C ）里所说的栈非常相似：它们都存储局部变量和表达式计算过程的中间量，并且在方法/函数的调用和返回过程发挥重要作用。
由于 JVM 栈不会被除 push & pop frames 以外的操作改变，栈帧可以在堆里构建。

*在栈这种先进后出的线性数据结构中，我们一般称向其中加入元素操作为 push, 移除其中元素为 pop.* 

对于 JVM 来说，它的线程栈在内存上的布局不必是连续的。

> 在 *The Java® Virtual Machine Specification* 第一版，Java Virtual Machine Stack 又被称作 Java Stack. 

本规范允许 JVM 栈使用定长结构或事先通过计算构造的可拓展的结构。
如果 JVM 栈有一个固定的大小，那么各线程栈的大小也可以在它们被创建时独立地设置。

> JVM 实现可以提供给程序员和用户设置 JVM 线程栈的初始大小，在其拓展改变时允许的空间大小范围。

下面列出了一些与 JVM 栈有关的异常条件：

- 如果一个线程需要使用一个超过允许大小的线程栈空间，JVM 应该抛出一个异常 `StackOverflowError`. 
- 如果一个线程栈可以动态的拓展，并且其在拓展的过程中发现剩余的内存不足以完成该拓展，或者一个新线程无法找到足够的内存来构建一个新的线程栈，JVM 应该抛出一个异常 `OutOfMemoryError`. 

*译者注：思考题 ～ 这两个 Error 定义在哪里？* 

#### Chapter 2.5.3 堆 (heap) 

JVM 在运行的过程中，有一个可供所有线程使用的全局堆。
该堆属于运行时数据区，而所有的对象、数组结构的构造所需要的内存都来自于这里。

该堆在 VM 初始化时创建。JVM 会使用一种自动化的存储策略管理系统（又称垃圾回收器）来回收不再使用的对象空间。
对象不会被显式地析构回收。
规范不会假定 JVM 使用某种垃圾回收策略，该技术可以根据实现者的系统需求自由选择。

堆本身可以是固定大小的，也可以是允许伸缩拓展的。
堆本身的内存布局不必是连续的。

下面有一个与其相关的异常：

- 如果在程序运行的过程中，内存管理系统需要的内存超过了堆能提供的能力范围，JVM 应该抛出一个异常 `OutOfMemoryError`. 

#### Chapter 2.5.4 方法区 (Method Area) 

JVM 有一个全局方法区。
这有点像进程里的 `text` 段，或者说像编程里所说的机器码。
在这里，它记录了各 `class` 的结构信息，包括类常量池 ( *run-time constant pool* ), 类成员信息 ( *field* ) ，类方法信息 ( *method* )，各方法、构造器的字节码信息，和类和接口的初始化方法。
（译者注：这里的初始化方法应该是指签名为 `<init>` 和 `<clinit>` 的特殊方法。）
( 原文：It stores per-class structures such as the run-time constant pool, field and method data, and the code for methods and constructors, including the special methods used in class and interface initialization and in instance initialization. )

方法区在虚拟机创建时被初始化。虽然方法区是堆的逻辑组成——如果你既不对它做垃圾回收，也不在上面跑某种压缩算法。
本规范不强制规定方法区所在的内存位置和在管理字节码时使用的策略。
就如堆那样，方法区既可以用定长结构实现，也可以设计成可伸缩结构。
方法区的内存不需要是连续的。

> 关于方法区的内存大小，JVM 实现也可以像「线程栈」那样提供额外的选项。

方法区相关的异常：

- 如果方法区没有足够的内存以供使用，抛出一个异常 `OutOfMemoryError`. 

#### Chapter 2.5.5 类常量池 (Run-Time Constant Pool)

类常量池是 `constant_pool` 表的运行时表示，该表定义于 `class` 文件中。
其包含各类常量，从编译时已知的数值常量，到不得不在运行时才能解析具体值的方法、成员变量引用。
对于常量池来说，一个函数，就像是一般程序的符号表里的一个符号一样。
尽管，事实上，常量池包含的数据种类远远多于符号表。

每个常量池所需要的内存都从 JVM 的方法区中获取，即接受方法区的内存分配器管理。
而对于一个类（或接口）来说，当它被 JVM 创建的同时，它的常量池也同时被构建出来。

常量池相关的异常：

- 当创建一个类时，如果构建常量池时所需要的内存超出了方法区可提供的范围，JVM 抛出异常 `OutOfMemoryError`. 

Chapter 5 会就类的装载、链接与初始化进一步讲解常量池。

#### Chapter 2.5.6 native 方法栈 (native method stacks / 本地方法栈)

对于 JVM 来说，一种简单的实现是使用传统的栈，或者说叫 C 栈，来支持 native 方法调用。
native 方法是指用不是 Java 语言写出来的方法。
Native 方法栈也可以被 JVM 指令的解释器（一般用像 C 这样的语言来实现）所使用。
如果 JVM 实现不打算支持对 `native` 方法的装载，且不依赖于传统的栈内存布局，则不需要提供 native 方法栈。
如果提供，native 方法栈需要在线程创建时显式地构造出来。

*译者注：关于 native 方法的描述，更准确的说法是通过宿主机平台实现的方法。*

该规范允许 native 方法栈设计为定长或动态的。如果其是定长的，不同线程也可以自行选择自己喜欢的大小。 

> 实现也可以允许用户指定其内存大小或范围。

相关异常：

- 方法栈如果超出了许可范围，抛出异常 `StackOverflowError`. 
- 方法栈所需内存不够，或构建新线程时没有足够的内存构建方法栈，抛出异常 `OutOfMemoryError`. 

### Chapter 2.6 栈帧 (Frames) 

栈帧用于存储数据和中间量，也可以用于执行动态链接，在方法中执行返回操作，及异常的分派处理。

每当一个方法被调用时，我们会创建一个新的栈帧。
而它会在该方法调用完成时销毁，无论这个调用是执行完成还是被异常打断（即抛出了一个不能在当前调用里处理的异常）。
栈帧在对应的线程栈中分配内存。
每个栈帧都有自己独有的局部变量列表，操作数栈，和当前方法所在的类常量池引用。

> 一个栈帧比我预期设计的更大，如果你包含了一些 debug 信息在里面的话。

由于局部变量列表也好，操作数栈也好，这些信息都可以在编译的过程中获取，并将其标记在该方法的 `code` 属性上。
因此，栈帧的容量只取决于 JVM 的实现和方法调用时可被同时分配的内存。

而对于线程栈，只有当前正在执行的方法是活动的。这个栈帧被认为是当前栈帧 (current frame) ，而它的方法则为当前方法 (current method) , 方法定义所在的类为当前类 (current class) . 
对局部变量和操作数栈的操作，是指对当前栈帧的这些成员的操作。

一个栈帧不再是 current 了，当且仅当其调用了另一个方法或者它的方法完成了。
当一个方法被调用时，我会创建一个新的栈帧，作为新的当前栈帧，并取得程序的控制权。
当方法完成时，方法调用的结果会从当前的栈帧传递至先前的栈帧上。
之后，当前栈帧被移除，而先前的一个栈帧成为新的 current frame. 

栈帧是线程的私有物，不可以被其他线程访问、引用。

#### Chapter 2.6.1 局部变量 (local variables) 

栈帧存储的变量列表称为它的「局部变量」。
在与当前将要创建的栈帧相关联的方法属性 *code* 上，可以找到其需要存储的变量列表长度。

一个局部变量足以存储 `boolean` , `byte` , `char` , `short` , `int` , `float` , `reference` , `returnAddress` 这些类型中的任一值。
而两个相邻局部变量才能够存储 `long` 和 `double` 类型的值。

局部变量通过在列表中的索引来定位和指示。
第一位的索引编号是 0. 
如果一个整数在 0 到变量表的长度之间（左闭右开），则它可以被视为对变量表的索引。

注意，`long` 类型和 `double` 类型需要使用两个连续的局部变量来描述。
对于这种情况，它的索引会是更小的那个局部变量的索引值。
比方说，有一个 `double` 类型的索引值为 3. 那么它实际占据的便是局部变量表中编号为 3 和 4 的两个位置。
然而，4 号位置不引该成为 *load* 操作的索引值。不过，如果你尝试对 4 号位置进行 *store* , 是可行的，与此同时，原来位于 3 号位置的 `double` 变量会失效。

正如上面的例子那样，这种占据两个变量位置的「林肯加长款」不需要保证编号是一个偶数。（这种约束对于计算机来说非常常见，因为它可以间接地保证内存对齐，使得对它的操作速度更快。）
但与此同时，JVM 实现必须要考虑好使用合适的方法来获取这个 `double` 值，小心一些架构里的 CPU misalign 错误！

JVM 使用局部变量作为方法调用的参数。
在方法的调用上，所有的参数通过从零开始的连续局部变量传递。
其中，编号为 0 的局部变量存储当前调用的对象，就像 C++ 里的 this 指针。
其他的参数，就从 1 开始存储在变量表中啦。

#### Chapter 2.6.2 操作数栈 (operand stacks) 

每个栈帧，都有一个栈，称作操作数栈。（栈是一种先进后出 LIFO 结构。）
就像变量表一样，它在运行期间的最大容量已经被编译器提前计算好并放在方法的 code 属性中。

如果不产生歧义，当前函数栈帧的操作数栈，会被简称为「操作数栈」。

当栈帧被创建时，它的操作数栈是空的。
JVM 提供了将编译时就已知的常量、局部变量的值或域装载至操作数栈中。
其他 JVM 指令则会从操作数栈中取出操作数，并操作它们，再将结果重新放回操作数栈中。
操作数栈的另一用途则是为方法的调用预备传参，并接收它的返回值。

比方说，指令 `iadd` 将两个 `int` 值加到一起，这两个 `int` 原先应该在操作数栈的顶部。
而在这条指令之后，原先这两个 `int` 值会被弹出操作数栈，而结果会被置入栈的顶端。
子计算的过程中间量，可能会被嵌套运算在操作数栈上，这样其中的结果便可以在整个运算过程中。

「原文：*Subcomputations may be nested on the operand stack, resulting in values that can be used by the encompassing computation.* 」

操作数栈上，每条条目可以保存一个 JVM 类型，包括 `long` 和 `double` 。
*译者注：这里似乎前文描述冲突*

在操作数栈上的值必须根据它们的实际类型，正确地被使用。
如果说，你把两个 `int` 置入操作数栈中，然后立刻把它当成一个 `long` 类型使用；再比方说，你置入两个 `float` 类型，然后来了一句 `iadd` 指令（处理 `int` 类型加法的指令）。这些行为 JVM 都绝不会允许！
还有一些指令，像 `dup` 和 `swap`, 会把这些数据当成一种 `raw` 类型（无类型，原始数据形式）去处理，而忽略它原本的实际类型。
但这些处理 `raw` 类型的指令设计在定义的时候，就已经保证它们无法真正地修改、破坏一个完整的数据结构。
而这些关于操作数栈上操作的限制，在一个 class 文件被装入虚拟机时，会被强制检查核对。

所以，对于操作数栈来说，任何时候，它都能够用一个「深度」的数据来描述，对里面的数据来说，`long` 和 `double` 会占 2 单位的深度，而其他是 1 单位。

#### Chapter 2.6.3 动态链接

每个函数栈帧，里面都会包含一个「引用」值，用于引用当前方法的类的运行时常量池。

*这句话对于没有 Java 背景的人来说可能有点费解。在 Java 的规定中，类 (`class`) 是虚拟机里的基本元素，对象 (`object`) 是类的一种具体数据表现。*
*同样的，方法/函数，也必须定义在一个类下，作为它的「成员方法」。*
*因此，任何一个方法，它都会归属于唯一的一个类，在上文中所指的类便是指它定义时的归属类。*

而这个「引用」的设计，便是虚拟机的「动态链接」机制的支持支柱。
方法通过符号引用来访问变量，调用其他方法。
而动态链接的过程将会将这些方法引用符号转化为具体的方法引用，当然，必要的情况下会装载类以解析尚未明确的符号，并把变量访问的过程解释成，根据这些变量的运行时位置，找到合理的内存偏移，再加以访问。

这种变量、方法的延迟绑定机制使得一段代码使用的外部依赖类的变更，不太可能会破坏这段代码。

#### Chapter 2.6.4 方法调用正常结束

「方法调用正常结束」是说，该调用没有产生一个抛出该方法作用域的，无论是从虚拟机直接抛出，还是显式地从代码中抛出的异常。
当调用正常完成后，该方法会根据其签名所描述的返回类型，执行对应的 `return` 语句，以向调用者提供一个返回值。

#### Chpater 2.6.5 方法调用意外结束

当一个异常被抛出了该方法的作用域，该方法便意外 (abrupt) 结束。
除了虚拟机自身的异常抛出规范，指令 `athrow` 也可以显式地抛出一个异常。
当一个方法调用意外结束，它不再向调用者提供返回值。

### Chapter 2.7 对象的表示形式

Java 虚拟机没有强制规定对象 (object) 的内部结构表示方式。

*在 Oracle 的实现中，一个对象的引用是一个指针，指向另一个勾柄 (handle, 又作「句柄」)，而这个勾柄中包含三个指针：一个是指向该对象方法表的指针，一个指向表示该对象类型的 `class` 实例，还有一个指向了该对象实际数据所在内存中的位置。*

### Chapter 2.8 浮点运算

Java 虚拟机收录了 *IEEE 754 Standard* 规定的浮点运算规范的子集。

*在 Java SE 15 及之后，JVM 使用了 2019 版本的该规范。在此之前，JVM 使用的是 1985 版本的规范——在那个版本中，`binary32` 格式又被称作 `float` 格式，`binary64` 又称 `double`.*

在 JVM 上，很多指令都用于浮点数的运算和类型变换。
除了下面列出的这些指令以外，其他指令都与 IEEE 754 定义的操作直接对应。

|指令|IEEE 754 指令|
|---|---|
|dcmp \<op\>, fcmp \<op\>|compareQuietLess, compareQuietLessEqual, compareQuietGreater, compareQuietGreaterEqual, compareQuietEqual, compareQuietNotEqual|
|dadd, fadd|addition|
|dsub, fsub|subtraction|
|dmul, fmul|multiplication|
|ddiv, fdiv|division|
|dneg, fneg|negate|
|i2d, i2f, l2d, l2f|convertFromInt|
|d2i, d2l, f2i, f2l|convertToIntegerTowardZero|
|d2f, f2d|convertFormat|

而在 JVM 所支持的浮点数运算和 IEEE 754 标准之间，有一些至关重要的区别：

- 浮点取模指令 ( `drem` / `frem` ) 不是 IEEE 754 定义的取模操作。它们在实际计算的过程中，采用了一种默认向零取整的运算策略；而在 IEEE 754 的取模操作，则规定为近似至最近的整数。

- 浮点数变负的单元运算指令 `dneg` 和 `fneg` 和 IEEE 754 中 negate 操作的描述并不完全一致：在值为 NaN （即 Not A Number）的情况下，它的符号位 (sign bit) 不必翻转。

- 浮点数指令不会抛出异常，触发 **trap**, 或者其他类似的东西，来指示 IEEE 754 所描述的意外情况：除零运算，运算溢出（向上/向下），精度不足。

- JVM 也不支持 IEEE 754 中描述的通过信号来检查当前的浮点运算结果是否正确的手段，也没有关于算出 NaN 的指示信号。

- IEEE 754 本身有对舍入精度策略的描述属性，这与 JVM 中的浮点规则不同：JVM 不允许修改现有的浮点运算规则。

- JVM 不提供本身在 IEEE 754 便已有定义的 *binary32 extended* 和 *binary64 extended* 浮点数格式。也不可以使用超过 `float` 和 `double` 类型的范围和精度的浮点数类型进行计算和存储。

有些操作，在 IEEE 754 中有所描述，但在 JVM 中没有得到指令集上的对应，但它们通过 `Math` 和 `StrictMath` 类型中的方法被得到了有效的支持：比方说，求取平方根的方法 `sqrt`, 先乘再加的快速指令 `fma`, 以及满足 *IEEE 754 remainder* 要求的函数 `IEEEremainder`. 

*译者注：这个 `fma` 实在不好翻译，它对应的是 IEEE 754 中的操作 `fusedMultiplyAdd`, 简单来说，便是对于三操作数 x, y, z, 它可以为你计算结果 (x * y) + z.* 

JVM 还需要支持 IEEE 754 中的 subnormal numbers 及渐变下溢，这些功能使得我们可以更容易地去证明一个特定的数值算法的某些良好性质。

浮点数运算是对实数运算的近似。
虽然说，实数上的数字是无限（且稠密），而一种特定的浮点数格式只有有限个值。
而在 JVM 中，它的舍入策略正是要将一个实数值，转换为一个能被表示的浮点数值。
对于那些在浮点数的值域上下界之间的实数来说，一个连续实数段会被映射到一个浮点数上。
比如说，实数 1.5 会被映射到浮点数 1.5 上。
JVM 定义了两种舍入策略：

- 最近舍入策略几乎被用在了所有浮点数指令上，除了：整型数值的转换和取模运算。
如果对于一个实数来说，有两个可表示的值，且它们距离它相同，则选择最低有效位为零的浮点数作为它的浮点表示。
这个机制和 IEEE 754 的舍入方向规则 *roundTiesToEven* 有关。
*它被认为是最邻近舍入模式的标准。而 Java 的舍入策略也照抄了这一模式。*[[todo:重翻这段]]

- 向零舍入策略则是用于将浮点型数据转换为整型数据的指令：`d2i`, `d2l`, `f2i`, `f2l` 和浮点取模指令 `drem`, `frem`. 
在这种模式下，不能被精确表达的结果会被近似至不大于它的绝对值的浮点数中最近的那个。
而浮点转整型过程中，这个策略相当于截断小数位。
*这个策略对应于 IEEE 754 中的 <u>roundTowareZero</u>, 又称向零舍入（早在 IEEE 754 version 1985 标准中便被提出）。Java 也延用此命名。*

在 JVM 中，所有的浮点算术指令，都使用了上述两条舍入规则之一。
<!-- 在 JVM 中，所有的浮点算术指令，都选择了上述两条舍入规则中其中的一条。感谢 wentong~ 的改良 -->

*在 Java 1.0 和 1.1 中，浮点表达式的求值过程相当严格——这意味着每个浮点操作数都必须是满足 IEEE 754 binary32 或 binary64 类型表示的值，且其所得结果，也与其算符匹配。*

*求值过程的严格性使得结果可以被很好得预测，但在 Java 1.0 / 1.1 时代常见的处理器系列上造成了性能问题。因此，在接下来的 Java 1.2 到 Java SE 16, Java SE 平台允许 JVM 实现具有一到两个与浮点数类型相关联的值集合。`float` 类型关联了 **float value set** 和 **float-extended-exponent value set**, 而 `double` 类型关联了 **float value set** 和 **double-extended exponent value set**. 比起 **float value set**, **float-extended-exponent value set** 拥有着相同的精度但具备更高的指数位空间；**double-extended-exponent value set**同理。而缺省地使用这些拓展集，确实改善了 JVM 的性能。*

*出于兼容性考虑，Java 1.2 允许字节码文件禁止使用 **extended-exponent value set** 的实现。它可以通过在方法声明上设置 **ACC_STRICT** 标记来禁用它。**ACC_STRICT** 限制了这个方法必须使用 **float value set** 和  **double value set** 来进行浮点数操作，以确保这些指令的结果是充分能被预测的。在 Java 1.0, 1.1 中，标志位 **ACC_STRICT** 也有着同样的语义。*

*在 Java SE 17 及之后，Java SE 平台常常需要在浮点运算时严格求值。更新的处理器在使用严格模式进行浮点数运算时也不再遇到当年那样的性能问题。而这一规范也不再关联 `float`, `double` 类型与上述的四个值集，同样，标志位 **ACC_STRICT** 也不再影响浮点运算的求值。出于兼容性考虑，在主版本号为 40 - 60 之间，这一表示 **ACC_STRICT** 位模式的行为在主版本号 > 60 后会被取消。在未来的版本中，也许它会被赋矛另一不同的涵义。*

In Java SE 17 and later, the Java SE Platform always requires strict evaluation of floating-point expressions. Newer members of the processor families that had performance problems implementing strict evaluation no longer have that difficulty. This specification no longer associates float and double with the four value sets described above, and the ACC_STRICT flag no longer affects the evaluation of floating-point operations. For compatibility, the bit pattern assigned to denote ACC_STRICT in a class file whose major version number is 46-60 is unassigned (that is, does not denote any flag) in a class file whose major version number is greater than 60 (§4.6). Future versions of the Java Virtual Machine may assign a different meaning to the bit pattern in future class files.

<u>译者注：我才看到这，早知道前面这些我就不翻了，无语！...</u>

### Chapter 2.9 特殊方法

#### Chapter 2.9.1 实例初始化方法

一个类可以有任意多的初始化方法，它们和在 Java 中所写的构造器一一对应。

一个方法是初始化方法必须满足下列这些条件：

- 被定义在 `class` 中。
- 它的方法名为 "\<init\>"
- 它的返回值为 `void` .

具体地说，任何返回值非 `void` 的方法不是初始化方法。
在一个接口中，没有方法是初始化方法。
这些方法都不能被 JVM 指令调用，并且在格式化检查中会被拒绝。

JVM 强制要求了初始化方法的声明方式和使用方式。
在该声明中，方法的访问标志、代码段有所限制。(?) 
在使用过程中，初始化函数只能发生在使用 `invokespecial` 指令在一个未初始化的类实例上调用。

因为该函数名 \<init\> 在 Java 语言中并不是一个合法的标识符，它并不能直接在 Java 代码中被使用。

#### Chapter 2.9.2 类初始化方法

一个类、或者一个接口，至少有一个类初始化方法，而 JVM 会通过调用这个方法来初始化这个类或接口。

它也有这样一点要求：

- 方法名为 "\<clinit\>"

- 它的返回值为 `void` .

在版本号 >= 51.0 的字节码文件中，该方法会设置 *ACC_STATIC* 标志位，且不需要任何输入。

*ACC_STATIC* 标志的设置是从 Java SE 7 开始的，而无参签名的约定则是从 Java SE 9 开始的。
在那些版本号 <= 50.0 的字节码中，只要一个方法的名字为 \<clinit\>, 而且它的返回值为 `void`, 那它就是类初始化方法，至于是否设置了 *ACC_STATIC*, 是否有传参... 那就不管它了。

而其他被命名为 \<clinit\> 的方法，就不是类初始化方法了，同时，它们也不可能被 JVM 再调用了！（也不会被 JVM 中的任何指令调用，而在格式化检查中也会拒绝。）

#### Chapter 2.9.3 方法多态性签名

<!-- 一个方法是方法多态性签名，如果满足下面的所有条件：  -->

一个方法在满足下列条件后，我们称其为具有多态性签名：

- 它被定义在 `java.lang.invoke.MethodHandle` / `java.lang.index.VarHandle` 中。

- 它的传入参数只有一个类型：`Object[]`. 

- 它的签名上面有这样两个标志：*ACC_VARARGS* 和 *ACC_NATIVE*. 

JVM 在使用 `invokevirtual` 指令会特殊化地处理这种多态性方法，以实现对方法勾柄的高效调用和对 `java.lang.invoke.VarHandle` 对象所引用的变量的高效访问。

<!-- 一个方法勾柄总是动态强类型，并且直接执行引用 -->
方法勾柄是什么？它是对下层方法、构造器、域访问甚至机器级别的操作的可执行抽象，能够处理可能的参数传递和返回值传递，是一种动态强类型值。

`java.lang.invoke.VarHandle` 对象同样也是一个动态强类型值，引用了一个或一族的变量，包括静态成员变量域，非静态域，数组元素，堆外组件。
如果你感到好奇，通过查询 Java SE Platform API 中的 `java.lang.invoke` 包，来了解更多。

### Chapter 2.10 异常

异常呢，是 JVM 中类 `Throwable` 及其子类的实例。
抛出异常，是一种立刻发生的非局部控制流转移。

绝大多数异常都是「同步」发生的——即它是该线程运行过程中执行指令的结果。
但也有「异步」异常，与之不同的是，它可以在执行的任何时刻发生！

总共的情况有以下三种：

- 执行指令 `athrow`. 

- JVM 检查出了一个异常的指令执行情况：这种情形只会在下列一些情况发生：一句指令执行操作时违背了 Java 语言的语义规则，例如数组索引越界；或者在加载或链接程序的某个部分时发生了错误；或者超出了某个资源的限制，例如使用了太多的内存。

- 异步异常会因为以下情形发生：调用 `Thread` 或 `ThreadGroup` 的 `stop` 方法，或者 JVM 内部发生了错误。

`stop` 方法可以被一个线程调用，以影响另一个线程或者指定线程组中的所有线程。因为他们能够在线程执行的任何时刻发生，所以被称为「异步」异常。而内部错误也被认为是「异步」异常。

JVM 在抛出一个异步异常之前，能够执行有限而少量的指令。这种延迟性能够使得优化的代码在遵守 Java 语言语义的前提下，能够在合适的时候处理这些异常。 

一个简单的实现可能在每个控制流移动指令上轮询异步异常。由于程序里的异常有限，所以检测异步异常的过程只会造成一个可以被估计的延迟。如果这么做，那么在控制流移动指令间的代码就不会触发异步异常，这样代码生成器就可以灵活地重排这些代码，以获得更好的性能。更进一步的研究，可以参考论文：Polling Efficiently on Stock Hardware by Marc Feeley, Proc. 1993 Conference on Functional Programming and Computer Architecture, Copenhagen, Denmark, pp. 179–187. 

JVM 抛出异常这一过程是精确定义的：当控制流转移发生时，所有在抛出异常之前执行的指令都必须生效，而在抛出异常之后的指令都不会被执行。如果优化的代码在抛出异常的地方进行了一些推测性的执行，那么这些代码必须能够隐藏这些推测性的执行，以保证用户视角的程序状态与没有优化的情况下一致。 

JVM 中，每个方法都可以绑定若干异常处理器。异常处理器必须指定其预期处理的可能抛出异常的 JVM 字节码的范围，同时也描述了该处理器能够处理的异常类型，以及其处理该异常的机器码位置。一个异常当它在对应的字节码范围内被抛出时且它的类型可以协变至异常处理器所能处理的类型时，匹配该处理器。当异常被抛出时，JVM 会在当前方法中寻找其匹配的异常处理器，找到匹配的后，JVM 会进入其指定的异常处理代码。 

假使当前方法中，没有找到任何一个异常处理器，则会紧急结束当前方法调用。
在这一过程中，无论是当前方法中的局部变量，还是操作数栈，都会被丢弃，而帧也会顺势弹出，恢复至调用者方法上。
而如果此时异常还不能被处理，它会继续在该调用者方法的帧中被抛出，如此循环，直到抛出异常的方法调用链的顶端。 
假使在抛出异常的方法调用链的顶端，还是没有找到任何一个能够处理该异常的异常处理器，那么抛出异常的线程就会被终止。 

在这一过程中，有一件事情很重要，那就是异常处理器的搜索顺序。在类文件中，每个方法的异常处理器都会被存储在一个表中。在运行时，当一个异常被抛出时，JVM 会按照类文件中对应的异常处理器表中的顺序，从表的开头开始，对当前方法中的异常处理器进行搜索，以寻找匹配的异常处理器。 

注意到，JVM 并没有强制要求异常处理器表中的异常处理器的嵌套或者排序。Java 语言的异常处理语义只是通过与编译器的协作来实现的。即使类文件是由其他方式生成的时候，这一良定义的搜索过程也能够保证所有的 JVM 实现能够表现出一致性。

### Chapter 2.11 指令集摘要

JVM 指令集使用一个字节的操作码来指定接下来的操作类型，操作码后面跟着若干个操作数，这些操作数被用来提供给操作码所指定的操作。 
很多指令没有操作数，只有一个操作码。 

假如不考虑异常，JVM 解释器的内部循环可以被看作是一个简单的指令集解释器：

```C++
do {
    /* atomically calculate pc and fetch opcode at pc */ ;
    if (/* operands */ ) /* fetch operands */ ;
    /* execute the action for the opcode */ ; 
} while (/* there is more to do */);
``` 

操作码决定了接下来该操作所需要的操作数数目和大小。
如果操作数的大小超过一个字节，那么它们会以大端序（big-endian）的方式存储，即高位字节在前，低位字节在后。 
比方说，一个 16 bit 的无符号整数，会被存储为两个无符号字节，byte1 和 byte2，这样它的值就是 `(byte1 << 8) | byte2` 。

字节码的指令流是单字节对齐的（为啥不直接说不对齐呢，呵呵）。
唯一的例外是 lookupswitch 和 tableswitch 指令，它们所使用的操作数必须进行 4 字节对齐，因此编译器在编译时要对它们进行额外的补齐。

*这一决定反映出了一个有意的偏好，即代码的紧凑性，尽管这可能会以一些性能的损失为代价。*
*一个字节的操作码也限制了指令集的大小。*
*不对数据对齐做假设，意味着在许多机器上，大于一个字节的立即数必须在运行时从字节构造出来。*

TODO: 若干具体的指令的解释，太简单暂不译

#### Chapter 2.11.1 Java 虚拟机与它的类型
#### Chapter 2.11.2 存储指令和加载指令 
#### Chapter 2.11.3 算术指令 
#### Chapter 2.11.4 类型转换指令 
#### Chapter 2.11.5 对象操作指令 
#### Chapter 2.11.6 操作数栈控制指令
#### Chapter 2.11.7 控制流指令 
#### Chapter 2.11.8 方法调用指令和返回
#### Chapter 2.11.9 异常处理指令 
#### Chapter 2.11.10 同步指令 


### Chapter 2.12 类库

Java 虚拟机必须提供足够的支持，以便于实现 Java SE 平台的类库。因为这些类库中的一些类，其功能的实现不能离开 Java 虚拟机的支持。 

需要特别支持的类包括： 

反射：例如 `java.lang.reflect` 包中的类，以及 `Class` 类。 
类装载、类创建：例如 `java.lang.ClassLoader` 类。 
动态链接和初始化：例如 `java.lang.invoke.MethodHandle` 类。
安全：例如 `java.security` 包中的类，以及 `SecurityManager` 类。 
多线程：例如 `Thread` 类。 
弱引用：例如 `java.lang.ref` 包中的类。 
<!-- 本地方法：例如 `java.lang.Runtime` 类。 -->

以上列表旨在说明问题，并不全面。相关的详尽列表请参阅 Java SE 平台类库的相关规范。 

### Chapter 2.13 公共设计，私有实现 

到目前为止，本规范已经概述了 Java 虚拟机的公共视图：类文件格式和指令集。
这些组件对于Java虚拟机的硬件、操作系统和实现独立性至关重要。
实现者可能更倾向于将它们视为在每个实现 Java SE 平台的主机之间安全地通信程序片段的一种方式，而不是一个要严格遵循的蓝图。

了解公共设计和私人实现之间的界限很重要。
Java 虚拟机实现必须能够读取类文件，并准确地实现其中 Java 虚拟机代码的语义。
实现这一点的一种方法是将此文档作为规范，并按其字面意思实现该规范。
但是，对于实现者来说，在本规范的约束范围内修改和优化实现也是完全可行。
只要可以读取类文件格式并维护其代码的语义，实现者就可以以任何方式实现这些语义。
只要外部的接口被维护好，实现相关的细节就是实现者的事情了。 

还有些小小的例外：调试器、分析器和即时编译器都需要访问 Java 虚拟机的一些元素，这些元素通常被认为是在「魔法师的帐篷」里 (under the hood) 。
如果合适， Oracle 会与其他 JVM 实现者和工具供应商合作，为这些工具开发 Java 虚拟机的通用接口，并在行业中推广这些接口。

由于这种灵活性，实现者可以自由定制 JVM 的实现，以得到更好的性能表现、更少的内容占用及移植性。
这取决于实现者的目标。 
实现的范围包括以下内容：

- 在加载时或执行时将 Java 虚拟机代码翻译成另一个虚拟机的指令集。 
- 在加载时或执行时将 Java 虚拟机代码翻译成主机 CPU 的本机指令集（有时称为即时编译，或 JIT 编译）。 

虚拟机和对象文件格式的精确定义并不会严重限制实现者的创造力。
Java 虚拟机旨在支持许多不同的实现，为实现者提供新颖的解决方案，同时保持实现之间的兼容性。