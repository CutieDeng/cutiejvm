use std::{collections::VecDeque, num::NonZeroU16};

pub struct Reader {
    /// store the info to be consumed
    buffer: VecDeque<u8>, 
    check: bool, 
    version: Option<Version>, 
    constant_pool_count : Option<u16>, 
    constant_pool : Vec<ConstantPoolInfo>, 
    access_flags : Option<AccessFlagType>, 
    this_class : Option<NonZeroU16>, 
    super_class : Option<u16>, 
    interfaces_count : Option<u16>, 
    interfaces : Vec<u16>, 
    fields_count : Option<u16>, 
    fields : Vec<FieldInfoType>, 
    methods_count : Option<u16>, 
    methods : Vec<MethodInfoType>, 
    attributes_count : Option<u16>, 
    attributes : Vec<AttributeInfoType>, 
}

type FieldInfoType = (); 
type MethodInfoType = (); 
type AttributeInfoType = (); 

pub mod access_flags { 
    type AccessFlagIntType = u16; 
    pub const PUBLIC : AccessFlagIntType = 0x1; 
    pub const FINAL : AccessFlagIntType = 0x10; 
    pub const SUPER : AccessFlagIntType = 0x20; 
    pub const INTERFACE : AccessFlagIntType = 0x200; 
    pub const ABSTRACT : AccessFlagIntType = 0x400; 
    pub const SYNTHETIC : AccessFlagIntType = 0x1000; 
    pub const ANNOTATION : AccessFlagIntType = 0x2000; 
    pub const ENUM : AccessFlagIntType = 0x4000; 
    pub struct AccessFlagType (AccessFlagIntType); 
    impl AccessFlagType {
        /// If yes, this class is visible and accessible for the package outs. 
        pub fn is_public(&self) -> bool {
            self.0 & PUBLIC != 0 
        }
        /// If yes, this class can't have sub types. 
        pub fn is_final(&self) -> bool {
            self.0 & FINAL != 0
        }
        /// [deprecated] JDK 1.0.2 before, it's considered a special case to handle. 
        #[deprecated = "After JDK 1.0.2, all class would take it."]
        pub fn is_super(&self) -> bool {
            self.0 & SUPER != 0
        }
        /// If yes, this class is interface but not class. 
        /// 
        /// If one is interface, it can't be `final`, `super` and `enum` absolutely! 
        pub fn is_interface(&self) -> bool {
            self.0 & INTERFACE != 0
        }
        /// If yes, this class can't be constructed. 
        pub fn is_abstract(&self) -> bool {
            self.0 & ABSTRACT != 0
        }
        /// If yes, this class is generated by compiler implicitly. 
        pub fn is_synthetic(&self) -> bool {
            self.0 & SYNTHETIC != 0 
        }
        /// If yes, this class is the type of annotation. 
        pub fn is_annotation(&self) -> bool {
            self.0 & ANNOTATION != 0
        }
        /// If yes, this class is the type of enum. 
        /// 
        /// If a class is with `enum` flag, it means it or its parent is enum. 
        pub fn is_enum(&self) -> bool {
            self.0 & ENUM != 0
        }
    }
}

use access_flags::AccessFlagType; 

type ConstantPoolInfo = (); 

/// Magic Number, to check the class file format is correct or not. 
const MAGIC_NUMBER : u32 = 0xCAFEBABE; 

struct Version {
    pub minor : u16, 
    pub major : u16, 
}

pub mod constant_pool {
    macro_rules! defu8 {
        ($a: ident, $b: literal) => {
            pub const $a : u8 = $b; 
        };
    }
    defu8!(CLASS, 7); 
    defu8!(FIELD_REF, 9); 
    defu8!(METHOD_REF, 10); 
    defu8!(INTERFACE_METHOD_REF, 11); 
    defu8!(STRING, 8); 
    defu8!(INTEGER, 3); 
    defu8!(FLOAT, 4); 
    defu8!(LONG, 5); 
    defu8!(DOUBLE, 6); 
    defu8!(NAME_AND_TYPE, 12); 
    defu8!(UTF8, 1); 
    defu8!(METHOD_HANDLE, 15); 
    defu8!(METHOD_TYPE, 16); 
    defu8!(INVOKE_DYNAMIC, 18); 

    pub type Piece = super::ConstantPoolPiece; 

}

type ConstantClassInfo = (); 

pub enum RefType {
    InterfaceMethod, 
    Method, 
    Field, 
}

pub enum ConstantPoolPiece {
    Class { name_index : u16, }, 
    Ref { class_index : u16, name_and_type_index : u16, ref_type : RefType, }, 
    String { string_index : u16, }, 
    Integer ( i32 ), 
    Float ( f32 ), 
    Long ( i64 ), 
    Double ( f64 ), 
    NameAndType { name_index : u16 , descriptor_index : u16 , }, 
    UtfInfo (String ), 

}

impl ConstantPoolPiece {
    /// get float value from 4 bytes. 
    pub fn new_float( bytes: u32 ) -> f32 {
        let val = match bytes {
            0x7f80_0000 => f32::INFINITY, 
            0xff80_0000 => f32::NEG_INFINITY, 
            a if ( a >= 0x7f80_0001 && a <= 0x7fff_ffff ) || a >= 0xff800001 => f32::NAN, 
            a => {
                let s = if a >> 31 == 0 { 1 } else { -1 }; 
                let e = a >> 23 & 0xff; 
                let m = if e == 0 { ( a & 0x007f_ffff ) << 1 } else { ( a & 0x007f_ffff ) | 0x0080_0000 };  
                let s = s as f32; 
                let m = m as f32; 
                let e = (e as i32) - 150; 
                let e = e as f32; 
                let e = e.exp2(); 
                s * m * e
            }
        }; 
        val 
    }
}

impl ConstantPoolPiece {
    /// get double value from 8 bytes. 
    pub fn new_double( low_bytes : u32, high_bytes : u32 ) -> f64 {
        let bits = (low_bytes as u64) | (high_bytes as u64) << 32; 
        let val = match bits {
            0x7ff00000_00000000 => f64::INFINITY, 
            0xfff00000_00000000 => f64::NEG_INFINITY, 
            a if a >= 0x7ff00000_00000001 && a <= 0x7fffffff_ffffffff || a >= 0xfff00000_00000001 => { f64::NAN }, 
            bits => {
                let s = if bits >> 63 == 0 { 1 } else { -1 } ; 
                let e = ( bits >> 52 & 0x7ff ) as u32; 
                let m = if e == 0 { ( bits & 0xfffff_ffffffff ) << 1 } else { bits & 0xfffff_ffffffff | 0x100000_00000000 }; 
                let s = s as f64; 
                let m = m as f64; 
                let e = (e as i32 - 1075) as f64; 
                let e = e.exp2(); 
                s * m * e
            }
        }; 
        val 
    }
}

enum ExtUtfParser {
    Nothing, 
    FiveUpperBit(u16), 
    ThreeBytes(u16, bool), 
    SpecialCase(u32, u8), 
}

impl ConstantPoolPiece {
    pub fn new_utf_info( utf: &[u8] ) -> Option<String> {
        let mut res = String::with_capacity(utf.len());
        let mut parser = ExtUtfParser::Nothing; 
        let mut it = utf.iter(); 
        'parser: 
        while let Some(&i) = it.next() {
            match parser {
                ExtUtfParser::Nothing => {
                    match i {
                        i if i & 0x80 == 0 => {
                            res.push(i as char); 
                        }
                        i if i & 0xE0 == 0xC0 => {
                            parser = ExtUtfParser::FiveUpperBit((i as u16 & 0x1f) << 6); 
                        }
                        i if i & 0xF0 == 0xE0 => {
                            parser = ExtUtfParser::ThreeBytes((i as u16 & 0xf) << 12, false); 
                        }
                        0xED => {
                            parser = ExtUtfParser::SpecialCase(0, 0); 
                        }
                        _ => return None,
                    }
                }
                ExtUtfParser::FiveUpperBit(mut b) => {
                    match i {
                        i if i & 0xC0 == 0x80 => {
                            b |= i as u16 & 0x3f; 
                            res.push ( std::char::from_u32(b as u32)? ); 
                            parser = ExtUtfParser::Nothing; 
                        }
                        _ => return None, 
                    }
                }
                ExtUtfParser::ThreeBytes(ref mut b, ref mut k) => {
                    let i = match i {
                        i if i & 0xC0 == 0x80 => {
                            i as u16 & 0x3f 
                        }
                        _ => return None, 
                    }; 
                    match k {
                        true => {
                            *b |= i; 
                            res.push( std::char::from_u32(*b as u32)? ); 
                            parser = ExtUtfParser::Nothing; 
                        }
                        false => {
                            *b |= i << 6; 
                            *k = true; 
                        }
                    }
                }
                ExtUtfParser::SpecialCase(ref mut a, ref mut index) => {
                    match index {
                        0 => {
                            match i {
                                i if i & 0xf0 == 0xa0 => { 
                                    let k = ( i & 0x0f ) + 1; 
                                    let k = (k as u32) << 16; 
                                    *a = k; 
                                }
                                _ => return None, 
                            }
                        },
                        1 => {
                            match i {
                                i if i & 0xB0 == 0x80 => {
                                    let k = ( i & 0x3F ) as u32; 
                                    let k = k << 10; 
                                    *a |= k; 
                                }
                                _ => return None, 
                            }
                        }
                        2 => {
                            match i {
                                0xED => (), 
                                _ => return None, 
                            }
                        }
                        3 => {
                            match i {
                                i if i & 0xF0 == 0xB0 => {
                                    let k = ( i & 0xF ) as u32; 
                                    let k = k << 6; 
                                    *a |= k; 
                                }
                                _ => return None, 
                            }
                        }
                        4 => {
                            match i {
                                i if i & 0xB0 == 0x80 => {
                                    let k = (i & 0x3F) as u32; 
                                    *a |= k; 
                                }
                                _ => return None, 
                            }
                            res.push( std::char::from_u32(*a)? ); 
                            parser = ExtUtfParser::Nothing; 
                            continue 'parser; 
                        }
                        _ => unreachable!(), 
                    }
                    *index += 1; 
                }
            }
        }
        let ExtUtfParser::Nothing = parser else {
            return None; 
        }; 
        Some(res) 
    }
}