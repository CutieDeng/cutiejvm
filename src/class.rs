use std::{collections::VecDeque, num::NonZeroU16};

pub struct Reader {
    /// store the info to be consumed
    buffer: VecDeque<u8>, 
    check: bool, 
    version: Option<Version>, 
    constant_pool_count : Option<u16>, 
    constant_pool : Vec<ConstantPoolInfo>, 
    access_flags : Option<AccessFlagType>, 
    this_class : Option<NonZeroU16>, 
    super_class : Option<u16>, 
    interfaces_count : Option<u16>, 
    interfaces : Vec<u16>, 
    fields_count : Option<u16>, 
    fields : Vec<FieldInfoType>, 
    methods_count : Option<u16>, 
    methods : Vec<MethodInfoType>, 
    attributes_count : Option<u16>, 
    attributes : Vec<AttributeInfoType>, 
}

type FieldInfoType = (); 
type MethodInfoType = (); 
type AttributeInfoType = (); 

pub mod access_flags { 
    type AccessFlagIntType = u16; 
    pub const PUBLIC : AccessFlagIntType = 0x1; 
    pub const FINAL : AccessFlagIntType = 0x10; 
    pub const SUPER : AccessFlagIntType = 0x20; 
    pub const INTERFACE : AccessFlagIntType = 0x200; 
    pub const ABSTRACT : AccessFlagIntType = 0x400; 
    pub const SYNTHETIC : AccessFlagIntType = 0x1000; 
    pub const ANNOTATION : AccessFlagIntType = 0x2000; 
    pub const ENUM : AccessFlagIntType = 0x4000; 
    pub struct AccessFlagType (AccessFlagIntType); 
    impl AccessFlagType {
        /// If yes, this class is visible and accessible for the package outs. 
        pub fn is_public(&self) -> bool {
            self.0 & PUBLIC != 0 
        }
        /// If yes, this class can't have sub types. 
        pub fn is_final(&self) -> bool {
            self.0 & FINAL != 0
        }
        /// [deprecated] JDK 1.0.2 before, it's considered a special case to handle. 
        #[deprecated = "After JDK 1.0.2, all class would take it."]
        pub fn is_super(&self) -> bool {
            self.0 & SUPER != 0
        }
        /// If yes, this class is interface but not class. 
        /// 
        /// If one is interface, it can't be `final`, `super` and `enum` absolutely! 
        pub fn is_interface(&self) -> bool {
            self.0 & INTERFACE != 0
        }
        /// If yes, this class can't be constructed. 
        pub fn is_abstract(&self) -> bool {
            self.0 & ABSTRACT != 0
        }
        /// If yes, this class is generated by compiler implicitly. 
        pub fn is_synthetic(&self) -> bool {
            self.0 & SYNTHETIC != 0 
        }
        /// If yes, this class is the type of annotation. 
        pub fn is_annotation(&self) -> bool {
            self.0 & ANNOTATION != 0
        }
        /// If yes, this class is the type of enum. 
        /// 
        /// If a class is with `enum` flag, it means it or its parent is enum. 
        pub fn is_enum(&self) -> bool {
            self.0 & ENUM != 0
        }
    }
}

use access_flags::AccessFlagType; 

type ConstantPoolInfo = (); 

/// Magic Number, to check the class file format is correct or not. 
const MAGIC_NUMBER : u32 = 0xCAFEBABE; 

struct Version {
    pub minor : u16, 
    pub major : u16, 
}

pub mod constant_pool {
    macro_rules! defu8 {
        ($a: ident, $b: literal) => {
            pub const $a : u8 = $b; 
        };
    }
    defu8!(CLASS, 7); 
    defu8!(FIELD_REF, 9); 
    defu8!(METHOD_REF, 10); 
    defu8!(INTERFACE_METHOD_REF, 11); 
    defu8!(STRING, 8); 
    defu8!(INTEGER, 3); 
    defu8!(FLOAT, 4); 
    defu8!(LONG, 5); 
    defu8!(DOUBLE, 6); 
    defu8!(NAME_AND_TYPE, 12); 
    defu8!(UTF8, 1); 
    defu8!(METHOD_HANDLE, 15); 
    defu8!(METHOD_TYPE, 16); 
    defu8!(INVOKE_DYNAMIC, 18); 

    pub type Piece = super::ConstantPoolPiece; 

}

type ConstantClassInfo = (); 

pub enum RefType {
    InterfaceMethod, 
    Method, 
    Field, 
}

pub enum ConstantPoolPiece {
    Class { name_index : u16, }, 
    Ref { class_index : u16, name_and_type_index : u16, ref_type : RefType, }, 
    String { string_index : u16, }, 
    Integer ( i32 ), 
    Float ( f32 ), 
    Long ( i64 ), 
    Double ( f64 ), 
    NameAndType { name_index : u16 , descriptor_index : u16 , }, 
}

impl ConstantPoolPiece {
    /// get float value from 4 bytes. 
    pub fn new_float( bytes: u32 ) -> f32 {
        let val = match bytes {
            0x7f80_0000 => f32::INFINITY, 
            0xff80_0000 => f32::NEG_INFINITY, 
            a if ( a >= 0x7f80_0001 && a <= 0x7fff_ffff ) || a >= 0xff800001 => f32::NAN, 
            a => {
                let s = if a >> 31 == 0 { 1 } else { -1 }; 
                let e = a >> 23 & 0xff; 
                let m = if e == 0 { ( a & 0x007f_ffff ) << 1 } else { ( a & 0x007f_ffff ) | 0x0080_0000 };  
                let s = s as f32; 
                let m = m as f32; 
                let e = (e as i32) - 150; 
                let e = e as f32; 
                let e = e.exp2(); 
                s * m * e
            }
        }; 
        val 
    }
}

impl ConstantPoolPiece {
    pub fn new_double( low_bytes : u32, high_bytes : u32 ) -> f64 {
        let bits = (low_bytes as u64) | (high_bytes as u64) << 32; 
        let val = match bits {
            0x7ff00000_00000000 => f64::INFINITY, 
            0xfff00000_00000000 => f64::NEG_INFINITY, 
            a if a >= 0x7ff00000_00000001 && a <= 0x7fffffff_ffffffff || a >= 0xfff00000_00000001 => { f64::NAN }, 
            bits => {
                let s = if bits >> 63 == 0 { 1 } else { -1 } ; 
                let e = ( bits >> 52 & 0x7ff ) as u32; 
                let m = if e == 0 { ( bits & 0xfffff_ffffffff ) << 1 } else { bits & 0xfffff_ffffffff | 0x100000_00000000 }; 
                let s = s as f64; 
                let m = m as f64; 
                let e = (e as i32 - 1075) as f64; 
                let e = e.exp2(); 
                s * m * e
            }
        }; 
        val 
    }
}